#include "stdafx.h"
#include "DES.h"
#include <string>
//#include <iostream>

using namespace std;

typedef unsigned int word32;
typedef unsigned int uint32;

typedef struct {
	word32 k0246[16], k1357[16];
	word32 iv0, iv1;
} DESContext;

#define rotl(x, c) ( (x << c) | (x >> (32-c)) )
#define rotl28(x, c) ( ( (x << c) | (x >> (28-c)) ) & 0x0FFFFFFF)

static word32 bitsel(word32* input, const int* bitnums, int size)
{
	word32 ret = 0;
	while (size--) {
		int bitpos = *bitnums++;
		ret <<= 1;
		if (bitpos >= 0)  
			ret |= 1 & (input[bitpos / 32] >> (bitpos % 32));
	}
	return ret;
}

static void des_key_setup(word32 key_msw, word32 key_lsw, DESContext* sched)
{

	static const int PC1_Cbits[] = {
	7, 15, 23, 31, 39, 47, 55, 63, 6, 14, 22, 30, 38, 46,
	54, 62, 5, 13, 21, 29, 37, 45, 53, 61, 4, 12, 20, 28
	};
	static const int PC1_Dbits[] = {
	1, 9, 17, 25, 33, 41, 49, 57, 2, 10, 18, 26, 34, 42,
	50, 58, 3, 11, 19, 27, 35, 43, 51, 59, 36, 44, 52, 60
	};
	/*
	 * The bit numbers in the two lists below don't correspond to
	 * the ones in the above description of PC2, because in the
	 * above description C and D are concatenated so `bit 28' means
	 * bit 0 of C. In this implementation we're using the standard
	 * `bitsel' function above and C is in the second word, so bit
	 * 0 of C is addressed by writing `32' here.
	 */
	static const int PC2_0246[] = {
	49, 36, 59, 55, -1, -1, 37, 41, 48, 56, 34, 52, -1, -1, 15, 4,
	25, 19, 9, 1, -1, -1, 12, 7, 17, 0, 22, 3, -1, -1, 46, 43
	};
	static const int PC2_1357[] = {
	-1, -1, 57, 32, 45, 54, 39, 50, -1, -1, 44, 53, 33, 40, 47, 58,
	-1, -1, 26, 16, 5, 11, 23, 8, -1, -1, 10, 14, 6, 20, 27, 24
	};
	static const int leftshifts[] =
	{ 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 };

	word32 C, D;
	word32 buf[2];
	int i;

	buf[0] = key_lsw;
	buf[1] = key_msw;

	C = bitsel(buf, PC1_Cbits, 28);
	D = bitsel(buf, PC1_Dbits, 28);

	for (i = 0; i < 16; i++) {
		C = rotl28(C, leftshifts[i]);
		D = rotl28(D, leftshifts[i]);
		buf[0] = D;
		buf[1] = C;
		sched->k0246[i] = bitsel(buf, PC2_0246, 32);
		sched->k1357[i] = bitsel(buf, PC2_1357, 32);
	}

	sched->iv0 = sched->iv1 = 0;
}

static const word32 SPboxes[8][64] = {
	{0x01010400, 0x00000000, 0x00010000, 0x01010404,
	 0x01010004, 0x00010404, 0x00000004, 0x00010000,
	 0x00000400, 0x01010400, 0x01010404, 0x00000400,
	 0x01000404, 0x01010004, 0x01000000, 0x00000004,
	 0x00000404, 0x01000400, 0x01000400, 0x00010400,
	 0x00010400, 0x01010000, 0x01010000, 0x01000404,
	 0x00010004, 0x01000004, 0x01000004, 0x00010004,
	 0x00000000, 0x00000404, 0x00010404, 0x01000000,
	 0x00010000, 0x01010404, 0x00000004, 0x01010000,
	 0x01010400, 0x01000000, 0x01000000, 0x00000400,
	 0x01010004, 0x00010000, 0x00010400, 0x01000004,
	 0x00000400, 0x00000004, 0x01000404, 0x00010404,
	 0x01010404, 0x00010004, 0x01010000, 0x01000404,
	 0x01000004, 0x00000404, 0x00010404, 0x01010400,
	 0x00000404, 0x01000400, 0x01000400, 0x00000000,
	 0x00010004, 0x00010400, 0x00000000, 0x01010004L},

	{0x80108020, 0x80008000, 0x00008000, 0x00108020,
	 0x00100000, 0x00000020, 0x80100020, 0x80008020,
	 0x80000020, 0x80108020, 0x80108000, 0x80000000,
	 0x80008000, 0x00100000, 0x00000020, 0x80100020,
	 0x00108000, 0x00100020, 0x80008020, 0x00000000,
	 0x80000000, 0x00008000, 0x00108020, 0x80100000,
	 0x00100020, 0x80000020, 0x00000000, 0x00108000,
	 0x00008020, 0x80108000, 0x80100000, 0x00008020,
	 0x00000000, 0x00108020, 0x80100020, 0x00100000,
	 0x80008020, 0x80100000, 0x80108000, 0x00008000,
	 0x80100000, 0x80008000, 0x00000020, 0x80108020,
	 0x00108020, 0x00000020, 0x00008000, 0x80000000,
	 0x00008020, 0x80108000, 0x00100000, 0x80000020,
	 0x00100020, 0x80008020, 0x80000020, 0x00100020,
	 0x00108000, 0x00000000, 0x80008000, 0x00008020,
	 0x80000000, 0x80100020, 0x80108020, 0x00108000L},

	{0x00000208, 0x08020200, 0x00000000, 0x08020008,
	 0x08000200, 0x00000000, 0x00020208, 0x08000200,
	 0x00020008, 0x08000008, 0x08000008, 0x00020000,
	 0x08020208, 0x00020008, 0x08020000, 0x00000208,
	 0x08000000, 0x00000008, 0x08020200, 0x00000200,
	 0x00020200, 0x08020000, 0x08020008, 0x00020208,
	 0x08000208, 0x00020200, 0x00020000, 0x08000208,
	 0x00000008, 0x08020208, 0x00000200, 0x08000000,
	 0x08020200, 0x08000000, 0x00020008, 0x00000208,
	 0x00020000, 0x08020200, 0x08000200, 0x00000000,
	 0x00000200, 0x00020008, 0x08020208, 0x08000200,
	 0x08000008, 0x00000200, 0x00000000, 0x08020008,
	 0x08000208, 0x00020000, 0x08000000, 0x08020208,
	 0x00000008, 0x00020208, 0x00020200, 0x08000008,
	 0x08020000, 0x08000208, 0x00000208, 0x08020000,
	 0x00020208, 0x00000008, 0x08020008, 0x00020200L},

	{0x00802001, 0x00002081, 0x00002081, 0x00000080,
	 0x00802080, 0x00800081, 0x00800001, 0x00002001,
	 0x00000000, 0x00802000, 0x00802000, 0x00802081,
	 0x00000081, 0x00000000, 0x00800080, 0x00800001,
	 0x00000001, 0x00002000, 0x00800000, 0x00802001,
	 0x00000080, 0x00800000, 0x00002001, 0x00002080,
	 0x00800081, 0x00000001, 0x00002080, 0x00800080,
	 0x00002000, 0x00802080, 0x00802081, 0x00000081,
	 0x00800080, 0x00800001, 0x00802000, 0x00802081,
	 0x00000081, 0x00000000, 0x00000000, 0x00802000,
	 0x00002080, 0x00800080, 0x00800081, 0x00000001,
	 0x00802001, 0x00002081, 0x00002081, 0x00000080,
	 0x00802081, 0x00000081, 0x00000001, 0x00002000,
	 0x00800001, 0x00002001, 0x00802080, 0x00800081,
	 0x00002001, 0x00002080, 0x00800000, 0x00802001,
	 0x00000080, 0x00800000, 0x00002000, 0x00802080L},

	{0x00000100, 0x02080100, 0x02080000, 0x42000100,
	 0x00080000, 0x00000100, 0x40000000, 0x02080000,
	 0x40080100, 0x00080000, 0x02000100, 0x40080100,
	 0x42000100, 0x42080000, 0x00080100, 0x40000000,
	 0x02000000, 0x40080000, 0x40080000, 0x00000000,
	 0x40000100, 0x42080100, 0x42080100, 0x02000100,
	 0x42080000, 0x40000100, 0x00000000, 0x42000000,
	 0x02080100, 0x02000000, 0x42000000, 0x00080100,
	 0x00080000, 0x42000100, 0x00000100, 0x02000000,
	 0x40000000, 0x02080000, 0x42000100, 0x40080100,
	 0x02000100, 0x40000000, 0x42080000, 0x02080100,
	 0x40080100, 0x00000100, 0x02000000, 0x42080000,
	 0x42080100, 0x00080100, 0x42000000, 0x42080100,
	 0x02080000, 0x00000000, 0x40080000, 0x42000000,
	 0x00080100, 0x02000100, 0x40000100, 0x00080000,
	 0x00000000, 0x40080000, 0x02080100, 0x40000100L},

	{0x20000010, 0x20400000, 0x00004000, 0x20404010,
	 0x20400000, 0x00000010, 0x20404010, 0x00400000,
	 0x20004000, 0x00404010, 0x00400000, 0x20000010,
	 0x00400010, 0x20004000, 0x20000000, 0x00004010,
	 0x00000000, 0x00400010, 0x20004010, 0x00004000,
	 0x00404000, 0x20004010, 0x00000010, 0x20400010,
	 0x20400010, 0x00000000, 0x00404010, 0x20404000,
	 0x00004010, 0x00404000, 0x20404000, 0x20000000,
	 0x20004000, 0x00000010, 0x20400010, 0x00404000,
	 0x20404010, 0x00400000, 0x00004010, 0x20000010,
	 0x00400000, 0x20004000, 0x20000000, 0x00004010,
	 0x20000010, 0x20404010, 0x00404000, 0x20400000,
	 0x00404010, 0x20404000, 0x00000000, 0x20400010,
	 0x00000010, 0x00004000, 0x20400000, 0x00404010,
	 0x00004000, 0x00400010, 0x20004010, 0x00000000,
	 0x20404000, 0x20000000, 0x00400010, 0x20004010L},

	{0x00200000, 0x04200002, 0x04000802, 0x00000000,
	 0x00000800, 0x04000802, 0x00200802, 0x04200800,
	 0x04200802, 0x00200000, 0x00000000, 0x04000002,
	 0x00000002, 0x04000000, 0x04200002, 0x00000802,
	 0x04000800, 0x00200802, 0x00200002, 0x04000800,
	 0x04000002, 0x04200000, 0x04200800, 0x00200002,
	 0x04200000, 0x00000800, 0x00000802, 0x04200802,
	 0x00200800, 0x00000002, 0x04000000, 0x00200800,
	 0x04000000, 0x00200800, 0x00200000, 0x04000802,
	 0x04000802, 0x04200002, 0x04200002, 0x00000002,
	 0x00200002, 0x04000000, 0x04000800, 0x00200000,
	 0x04200800, 0x00000802, 0x00200802, 0x04200800,
	 0x00000802, 0x04000002, 0x04200802, 0x04200000,
	 0x00200800, 0x00000000, 0x00000002, 0x04200802,
	 0x00000000, 0x00200802, 0x04200000, 0x00000800,
	 0x04000002, 0x04000800, 0x00000800, 0x00200002L},

	{0x10001040, 0x00001000, 0x00040000, 0x10041040,
	 0x10000000, 0x10001040, 0x00000040, 0x10000000,
	 0x00040040, 0x10040000, 0x10041040, 0x00041000,
	 0x10041000, 0x00041040, 0x00001000, 0x00000040,
	 0x10040000, 0x10000040, 0x10001000, 0x00001040,
	 0x00041000, 0x00040040, 0x10040040, 0x10041000,
	 0x00001040, 0x00000000, 0x00000000, 0x10040040,
	 0x10000040, 0x10001000, 0x00041040, 0x00040000,
	 0x00041040, 0x00040000, 0x10041000, 0x00001000,
	 0x00000040, 0x10040040, 0x00001000, 0x00041040,
	 0x10001000, 0x00000040, 0x10000040, 0x10040000,
	 0x10040040, 0x10000000, 0x00040000, 0x10001040,
	 0x00000000, 0x10041040, 0x00040040, 0x10000040,
	 0x10040000, 0x10001000, 0x10001040, 0x00000000,
	 0x10041040, 0x00041000, 0x00041000, 0x00001040,
	 0x00001040, 0x00040040, 0x10000000, 0x10041000L}
};

#define f(R, K0246, K1357) (\
    s0246 = R ^ K0246, \
    s1357 = R ^ K1357, \
    s0246 = rotl(s0246, 28), \
    SPboxes[0] [(s0246 >> 24) & 0x3F] | \
    SPboxes[1] [(s1357 >> 24) & 0x3F] | \
    SPboxes[2] [(s0246 >> 16) & 0x3F] | \
    SPboxes[3] [(s1357 >> 16) & 0x3F] | \
    SPboxes[4] [(s0246 >>  8) & 0x3F] | \
    SPboxes[5] [(s1357 >>  8) & 0x3F] | \
    SPboxes[6] [(s0246      ) & 0x3F] | \
    SPboxes[7] [(s1357      ) & 0x3F])

#define bitswap(L, R, n, mask) (\
    swap = mask & ( (R >> n) ^ L ), \
    R ^= swap << n, \
    L ^= swap)

/* Initial permutation */
#define IP(L, R) (\
    bitswap(R, L,  4, 0x0F0F0F0F), \
    bitswap(R, L, 16, 0x0000FFFF), \
    bitswap(L, R,  2, 0x33333333), \
    bitswap(L, R,  8, 0x00FF00FF), \
    bitswap(R, L,  1, 0x55555555))

/* Final permutation */
#define FP(L, R) (\
    bitswap(R, L,  1, 0x55555555), \
    bitswap(L, R,  8, 0x00FF00FF), \
    bitswap(L, R,  2, 0x33333333), \
    bitswap(R, L, 16, 0x0000FFFF), \
    bitswap(R, L,  4, 0x0F0F0F0F))

static void des_encipher(word32* output, word32 L, word32 R, DESContext* sched)
{
	word32 swap, s0246, s1357;

	IP(L, R);


	L = rotl(L, 1);
	R = rotl(R, 1);

	L ^= f(R, sched->k0246[0], sched->k1357[0]);
	R ^= f(L, sched->k0246[1], sched->k1357[1]);
	L ^= f(R, sched->k0246[2], sched->k1357[2]);
	R ^= f(L, sched->k0246[3], sched->k1357[3]);
	L ^= f(R, sched->k0246[4], sched->k1357[4]);
	R ^= f(L, sched->k0246[5], sched->k1357[5]);
	L ^= f(R, sched->k0246[6], sched->k1357[6]);
	R ^= f(L, sched->k0246[7], sched->k1357[7]);
	L ^= f(R, sched->k0246[8], sched->k1357[8]);
	R ^= f(L, sched->k0246[9], sched->k1357[9]);
	L ^= f(R, sched->k0246[10], sched->k1357[10]);
	R ^= f(L, sched->k0246[11], sched->k1357[11]);
	L ^= f(R, sched->k0246[12], sched->k1357[12]);
	R ^= f(L, sched->k0246[13], sched->k1357[13]);
	L ^= f(R, sched->k0246[14], sched->k1357[14]);
	R ^= f(L, sched->k0246[15], sched->k1357[15]);

	L = rotl(L, 31);
	R = rotl(R, 31);

	swap = L;
	L = R;
	R = swap;

	FP(L, R);

	output[0] = L;
	output[1] = R;
}

static void des_decipher(word32* output, word32 L, word32 R,
	DESContext* sched)
{
	word32 swap, s0246, s1357;

	IP(L, R);

	L = rotl(L, 1);
	R = rotl(R, 1);

	L ^= f(R, sched->k0246[15], sched->k1357[15]);
	R ^= f(L, sched->k0246[14], sched->k1357[14]);
	L ^= f(R, sched->k0246[13], sched->k1357[13]);
	R ^= f(L, sched->k0246[12], sched->k1357[12]);
	L ^= f(R, sched->k0246[11], sched->k1357[11]);
	R ^= f(L, sched->k0246[10], sched->k1357[10]);
	L ^= f(R, sched->k0246[9], sched->k1357[9]);
	R ^= f(L, sched->k0246[8], sched->k1357[8]);
	L ^= f(R, sched->k0246[7], sched->k1357[7]);
	R ^= f(L, sched->k0246[6], sched->k1357[6]);
	L ^= f(R, sched->k0246[5], sched->k1357[5]);
	R ^= f(L, sched->k0246[4], sched->k1357[4]);
	L ^= f(R, sched->k0246[3], sched->k1357[3]);
	R ^= f(L, sched->k0246[2], sched->k1357[2]);
	L ^= f(R, sched->k0246[1], sched->k1357[1]);
	R ^= f(L, sched->k0246[0], sched->k1357[0]);

	L = rotl(L, 31);
	R = rotl(R, 31);

	swap = L;
	L = R;
	R = swap;

	FP(L, R);

	output[0] = L;
	output[1] = R;
}



void DES_encrypt(unsigned k1, unsigned k2, unsigned m1, unsigned m2, unsigned& c1, unsigned& c2)
{
	word32 en_output[2];
	DESContext* sched = new DESContext;
	des_key_setup(k1, k2, sched);
	des_encipher(en_output, m1, m2, sched);
	c1 = en_output[0];
	c2 = en_output[1];
	delete sched;
}

void DES_decrypt(unsigned k1, unsigned k2, unsigned c1, unsigned c2, unsigned& m1, unsigned& m2)
{
	word32 de_output[2];
	DESContext* sched = new DESContext;
	des_key_setup(k1, k2, sched);
	des_decipher(de_output, c1, c2, sched);
	m1 = de_output[0];
	m2 = de_output[1];
	delete sched;
}


/*
	下面是对加密/解密函数的简单封装
*/
// 默认为大端存储，大端存储即数据的高字节保存在内存的低地址。

void bytes2uint(uchar bytes[4], uint& u32) {
	u32 = 0;
	for (int i = 0; i < 4; i++) {
		for (int j = 7; j >= 0; j--) {
			u32 <<= 1;
			u32 |= ((bytes[i] >> j) & 0x1);
		}
	}
}


void uint2bytes(uint u32, uchar bytes[4]) {
	for (int i = 0, k = 31; i < 4; i++) {
		bytes[i] = 0;
		for (int j = 0; j < 8; j++) {
			bytes[i] <<= 1;
			bytes[i] |= ((u32 >> k--) & 0x1);
		}
	}
}

// 加密函数的简答封装
/*--------------------------------------------------*/
/*          data encryption (des加密)               */
/*  参数 m_bit[8]:明文分组    k_bit[8]:密钥     e_bit[8]:密文分组 */
/*--------------------------------------------------*/
void __stdcall endes(unsigned char m_bit[8], unsigned char k_bit[8], unsigned char e_bit[8]) {
	uint k1, k2, m1, m2, c1, c2;
	bytes2uint(k_bit, k1);
	bytes2uint(k_bit + 4, k2);
	bytes2uint(m_bit, m1);
	bytes2uint(m_bit + 4, m2);
	DES_encrypt(k1, k2, m1, m2, c1, c2);
	uint2bytes(c1, e_bit);
	uint2bytes(c2, e_bit + 4);
}

// 解密函数的简答封装
/*--------------------------------------------------              */
/*                  data uncryption (des解密)                       */
/*  参数 m_bit[8]:密文分组    k_bit[8]:密钥     e_bit[8]:明文分组 */
/*--------------------------------------------------              */
void __stdcall undes(unsigned char m_bit[8], unsigned char k_bit[8], unsigned char e_bit[8]) {
	uint k1, k2, c1, c2, m1, m2;
	bytes2uint(k_bit, k1);
	bytes2uint(k_bit + 4, k2);
	bytes2uint(m_bit, c1);
	bytes2uint(m_bit + 4, c2);
	DES_decrypt(k1, k2, c1, c2, m1, m2);
	uint2bytes(m1, e_bit);
	uint2bytes(m2, e_bit + 4);
}

int __stdcall add(int a, int b)
{
	return a + b;
}
